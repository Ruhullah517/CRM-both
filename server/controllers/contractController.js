const GeneratedContract = require('../models/Contract');
const ContractTemplate = require('../models/ContractTemplate');
const { PDFDocument, StandardFonts } = require('pdf-lib');
const axios = require('axios');
const fs = require('fs');
const path = require('path');

// List all generated contracts
const getAllGeneratedContracts = async (req, res) => {
  try {
    const contracts = await GeneratedContract.find().populate('templateId').populate('generatedBy', 'name email');
    res.json(contracts);
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};

// Get a single generated contract by ID
const getGeneratedContract = async (req, res) => {
  try {
    const contract = await GeneratedContract.findById(req.params.id).populate('templateId').populate('generatedBy', 'name email');
    if (!contract) return res.status(404).json({ msg: 'Contract not found' });
    res.json(contract);
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};

// Generate a new contract from template and filled data
const generateContract = async (req, res) => {
  const { name, templateId, roleType, generatedBy, filledData, status } = req.body;
  
  try {
    // Validate required fields
    if (!templateId) {
      return res.status(400).json({ msg: 'Template ID is required' });
    }
    
    if (!generatedBy) {
      return res.status(400).json({ msg: 'Generated By is required' });
    }

    // Fetch template and validate placeholders
    const template = await ContractTemplate.findById(templateId);
    if (!template) {
      return res.status(400).json({ msg: 'Template not found' });
    }

    // Fill template content
    let filledContent = template.content;
    if (filledData && typeof filledData === 'object') {
      Object.entries(filledData).forEach(([ph, val]) => {
        filledContent = filledContent.replace(new RegExp(`{{\\s*${ph}\\s*}}`, 'g'), val || `[${ph}]`);
      });
    }

    // Generate PDF
    const pdfDoc = await PDFDocument.create();
    const page = pdfDoc.addPage();
    const { width, height } = page.getSize();
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const fontSize = 12;
    
    // Add BFCA header
    const headerFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
    page.drawText('BLACK FOSTER CARERS ALLIANCE', { 
      x: 40, 
      y: height - 40, 
      size: 16, 
      font: headerFont 
    });
    
    page.drawText('Black Foster Carers CIC', { 
      x: 40, 
      y: height - 60, 
      size: 12, 
      font: font 
    });
    
    page.drawText('6 St Michael Court, West Bromwich B70 BET, United Kingdom', { 
      x: 40, 
      y: height - 80, 
      size: 10, 
      font: font 
    });
    
    page.drawText('Email: Enquiries@blackfostercarersalliance.co.uk | Phone: 0800 001 6230', { 
      x: 40, 
      y: height - 100, 
      size: 10, 
      font: font 
    });
    
    // Add separator line
    page.drawLine({
      start: { x: 40, y: height - 120 },
      end: { x: width - 40, y: height - 120 },
      thickness: 1,
      color: { r: 0, g: 0, b: 0 }
    });

    // Split content into lines for PDF rendering
    const lines = filledContent.split('\n');
    let y = height - 140;
    
    lines.forEach(line => {
      if (y > 40) { // Prevent text from going off the page
        page.drawText(line, { x: 40, y, size: fontSize, font });
        y -= fontSize + 4;
      }
    });
    
    const pdfBytes = await pdfDoc.save();
    
    // Save PDF to disk
    const dirPath = path.join(__dirname, '../uploads/contracts');
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }
    
    const fileName = `contract_${Date.now()}.pdf`;
    const filePath = path.join(dirPath, fileName);
    fs.writeFileSync(filePath, pdfBytes);
    const generatedDocUrl = `/uploads/contracts/${fileName}`;

    if (req.body._id) {
      // Update existing contract
      const updated = await GeneratedContract.findByIdAndUpdate(
        req.body._id,
        {
          name,
          templateId,
          roleType,
          generatedBy,
          filledData,
          generatedDocUrl,
          status: status || 'pending',
        },
        { new: true }
      );
      res.status(200).json(updated);
    } else {
      // Create new contract
      const contract = new GeneratedContract({
        name,
        templateId,
        roleType,
        generatedBy,
        filledData,
        generatedDocUrl,
        status: status || 'pending',
      });
      await contract.save();
      res.status(201).json(contract);
    }
  } catch (error) {
    console.error('Contract generation error:', error);
    res.status(500).json({ 
      msg: 'Server error during contract generation',
      error: error.message 
    });
  }
};

// Send contract for e-signature via Adobe Sign
const sendForSignature = async (req, res) => {
  try {
    const { id } = req.params;
    const { accessToken, recipientEmail } = req.body;
    const contract = await GeneratedContract.findById(id);
    if (!contract) return res.status(404).json({ msg: 'Contract not found' });
    if (!contract.generatedDocUrl) return res.status(400).json({ msg: 'Generated PDF not found' });
    if (!accessToken || !recipientEmail) return res.status(400).json({ msg: 'Missing accessToken or recipientEmail' });

    // Build absolute path to PDF
    let filePath = contract.generatedDocUrl;
    if (filePath.startsWith('/')) filePath = filePath.slice(1);
    const absPath = path.resolve(__dirname, '../..', filePath);

    // Call local Adobe integration route to send agreement
    const baseUrl = process.env.BACKEND_BASE_URL || `http://localhost:${process.env.PORT || 5000}`;
    const response = await axios.post(`${baseUrl}/api/adobe/send-agreement`, {
      accessToken,
      recipientEmail,
      contractPath: absPath,
      contractName: contract.name || 'BFCA Contract'
    });

    const { agreementId, status } = response.data || {};
    contract.status = 'sent';
    contract.externalProvider = 'adobe';
    contract.externalAgreementId = agreementId || contract.externalAgreementId;
    await contract.save();
    res.json({ msg: 'Signature request sent', agreementId, providerStatus: status });
  } catch (error) {
    console.error('sendForSignature error:', error.response?.data || error.message);
    res.status(500).json({ msg: 'Failed to send for signature', error: error.response?.data || error.message });
  }
};

// Download contract PDF
const downloadContract = async (req, res) => {
  try {
    const contract = await GeneratedContract.findById(req.params.id);
    if (!contract || !contract.generatedDocUrl) return res.status(404).json({ msg: 'Contract or PDF not found' });
    // Remove leading slash if present
    let filePath = contract.generatedDocUrl;
    if (filePath.startsWith('/')) filePath = filePath.slice(1);
    const absPath = path.resolve(__dirname, '../..', filePath);
    if (!fs.existsSync(absPath)) return res.status(404).json({ msg: 'PDF file not found on server' });
    res.download(absPath, err => {
      if (err) {
        console.error('Download error:', err);
        res.status(500).send('Error downloading file');
      }
    });
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};

// Delete a generated contract
const deleteGeneratedContract = async (req, res) => {
  try {
    await GeneratedContract.findByIdAndDelete(req.params.id);
    res.json({ msg: 'Contract deleted' });
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};

module.exports = {
  getAllGeneratedContracts,
  getGeneratedContract,
  generateContract,
  sendForSignature,
  downloadContract,
  deleteGeneratedContract,
}; 