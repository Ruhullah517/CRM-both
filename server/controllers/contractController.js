const GeneratedContract = require('../models/Contract');
const ContractTemplate = require('../models/ContractTemplate');
const { PDFDocument, StandardFonts } = require('pdf-lib');
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const docusignService = require('../utils/docusign');
const { convert } = require('html-to-text');

// List all generated contracts
const getAllGeneratedContracts = async (req, res) => {
  try {
    const contracts = await GeneratedContract.find().populate('templateId').populate('generatedBy', 'name email');
    res.json(contracts);
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};

// Get a single generated contract by ID
const getGeneratedContract = async (req, res) => {
  try {
    const contract = await GeneratedContract.findById(req.params.id).populate('templateId').populate('generatedBy', 'name email');
    if (!contract) return res.status(404).json({ msg: 'Contract not found' });
    res.json(contract);
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};

// Generate a new contract from template and filled data
const generateContract = async (req, res) => {
  const { name, templateId, roleType, generatedBy, filledData, status } = req.body;
  
  // Valid status values
  const validStatuses = ['draft', 'pending', 'sent', 'delivered', 'signed', 'completed', 'declined', 'cancelled', 'expired'];
  const contractStatus = validStatuses.includes(status) ? status : 'draft';
  
  try {
    // Validate required fields
    if (!templateId) {
      return res.status(400).json({ msg: 'Template ID is required' });
    }
    
    if (!generatedBy) {
      return res.status(400).json({ msg: 'Generated By is required' });
    }

    // Fetch template and validate placeholders
    const template = await ContractTemplate.findById(templateId);
    if (!template) {
      return res.status(400).json({ msg: 'Template not found' });
    }

    // Fill template content
    let filledContent = template.content;
    if (filledData && typeof filledData === 'object') {
      Object.entries(filledData).forEach(([ph, val]) => {
        filledContent = filledContent.replace(new RegExp(`{{\\s*${ph}\\s*}}`, 'g'), val || `[${ph}]`);
      });
    }

    // Convert HTML to plain text for PDF generation
    const plainTextContent = convert(filledContent, {
      wordwrap: 80,
      preserveNewlines: true,
      selectors: [
        { selector: 'strong', format: 'bold' },
        { selector: 'b', format: 'bold' },
        { selector: 'em', format: 'italic' },
        { selector: 'i', format: 'italic' },
        { selector: 'u', format: 'underline' },
        { selector: 'br', format: 'lineBreak' },
        { selector: 'p', format: 'paragraph' },
        { selector: 'ul', format: 'unorderedList' },
        { selector: 'ol', format: 'orderedList' },
        { selector: 'li', format: 'listItem' }
      ]
    });

    // Generate PDF
    const pdfDoc = await PDFDocument.create();
    const page = pdfDoc.addPage();
    const { width, height } = page.getSize();
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const fontSize = 12;
    
    // Add logo to top right
    try {
      // Try multiple logo paths
      const logoPaths = [
        path.join(__dirname, '../uploads/logo.png'),
        path.join(__dirname, '../uploads/logo.PNG'),
        path.join(__dirname, '../../client/public/logo.PNG'),
        path.join(__dirname, '../../client/public/logo.png')
      ];
      
      let logoFound = false;
      for (const logoPath of logoPaths) {
        console.log('Checking logo at:', logoPath);
        if (fs.existsSync(logoPath)) {
          console.log('Found logo at:', logoPath);
          const logoBytes = fs.readFileSync(logoPath);
          console.log('Logo file size:', logoBytes.length, 'bytes');
          
          // Try to determine if it's PNG or JPG
          let logoImage;
          if (logoPath.toLowerCase().endsWith('.png')) {
            logoImage = await pdfDoc.embedPng(logoBytes);
          } else if (logoPath.toLowerCase().endsWith('.jpg') || logoPath.toLowerCase().endsWith('.jpeg')) {
            logoImage = await pdfDoc.embedJpg(logoBytes);
          } else {
            // Try PNG first, then JPG
            try {
              logoImage = await pdfDoc.embedPng(logoBytes);
            } catch (pngError) {
              console.log('PNG failed, trying JPG:', pngError.message);
              logoImage = await pdfDoc.embedJpg(logoBytes);
            }
          }
          
          const logoHeight = 60; // Logo height
          const logoWidth = 80; // Logo width (wider)
          console.log('Logo embedded successfully, drawing at:', {
            x: width - logoWidth - 20,
            y: height - logoHeight - 20,
            width: logoWidth,
            height: logoHeight
          });
          
          page.drawImage(logoImage, {
            x: width - logoWidth - 20, // 20px from right edge
            y: height - logoHeight - 20, // 20px from top
            width: logoWidth,
            height: logoHeight,
          });
          console.log('Logo drawn successfully');
          logoFound = true;
          break;
        }
      }
      
      if (!logoFound) {
        console.log('No logo file found in any of the expected locations');
      }
    } catch (error) {
      console.error('Error loading/embedding logo:', error);
    }
    
    // Add BFCA header
    const headerFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
    page.drawText('BLACK FOSTER CARERS ALLIANCE', { 
      x: 40, 
      y: height - 40, 
      size: 16, 
      font: headerFont 
    });
    
    page.drawText('Black Foster Carers CIC', { 
      x: 40, 
      y: height - 60, 
      size: 12, 
      font: font 
    });
    
    page.drawText('6 St Michael Court, West Bromwich B70 BET, United Kingdom', { 
      x: 40, 
      y: height - 80, 
      size: 10, 
      font: font 
    });
    
    page.drawText('Email: Enquiries@blackfostercarersalliance.co.uk | Phone: 0800 001 6230', { 
      x: 40, 
      y: height - 100, 
      size: 10, 
      font: font 
    });
    
    // Add separator line
    page.drawLine({
      start: { x: 40, y: height - 120 },
      end: { x: width - 40, y: height - 120 },
      thickness: 1
    });

    // Split content into lines for PDF rendering
    const lines = plainTextContent.split('\n');
    let y = height - 140;
    
    lines.forEach(line => {
      if (y > 40) { // Prevent text from going off the page
        page.drawText(line, { x: 40, y, size: fontSize, font });
        y -= fontSize + 4;
      }
    });
    
    const pdfBytes = await pdfDoc.save();
    
    // Save PDF to disk
    const dirPath = path.join(__dirname, '../uploads/contracts');
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }
    
    const fileName = `contract_${Date.now()}.pdf`;
    const filePath = path.join(dirPath, fileName);
    fs.writeFileSync(filePath, pdfBytes);
    
    // Use the correct server URL for the generated document URL
    const serverUrl = process.env.SERVER_URL || 'https://crm-backend-0v14.onrender.com';
    const generatedDocUrl = `${serverUrl}/uploads/contracts/${fileName}`;
    
    console.log('PDF saved to:', filePath);
    console.log('Generated doc URL:', generatedDocUrl);
    console.log('File exists after save:', fs.existsSync(filePath));

    if (req.body._id) {
      // Update existing contract
      const updated = await GeneratedContract.findByIdAndUpdate(
        req.body._id,
        {
          name,
          templateId,
          roleType,
          generatedBy,
          filledData,
          generatedDocUrl,
          status: contractStatus,
        },
        { new: true }
      );
      res.status(200).json(updated);
    } else {
      // Create new contract
      const contract = new GeneratedContract({
        name,
        templateId,
        roleType,
        generatedBy,
        filledData,
        generatedDocUrl,
        status: contractStatus,
      });
      await contract.save();
      res.status(201).json(contract);
    }
  } catch (error) {
    console.error('Contract generation error:', error);
    res.status(500).json({ 
      msg: 'Server error during contract generation',
      error: error.message 
    });
  }
};

// Send contract for e-signature via DocuSign
const sendForSignature = async (req, res) => {
  try {
    const { id } = req.params;
    const { recipientEmail, recipientName } = req.body;
    const contract = await GeneratedContract.findById(id);
    
    if (!contract) return res.status(404).json({ msg: 'Contract not found' });
    if (!contract.generatedDocUrl) return res.status(400).json({ msg: 'Generated PDF not found' });
    if (!recipientEmail) return res.status(400).json({ msg: 'Recipient email is required' });

    // Build absolute path to PDF
    let filePath = contract.generatedDocUrl;
    if (filePath.startsWith('http')) {
      // If it's an absolute URL, extract the file path
      const url = new URL(filePath);
      filePath = url.pathname;
    }
    if (filePath.startsWith('/')) filePath = filePath.slice(1);
    const absPath = path.resolve(__dirname, '../..', filePath);

    // Read PDF file and convert to base64
    const pdfBuffer = fs.readFileSync(absPath);
    const pdfBase64 = pdfBuffer.toString('base64');

    // Prepare contract data for DocuSign
    const contractData = {
      name: contract.name || 'BFCA Contract',
      recipientEmail,
      recipientName: recipientName || recipientEmail,
      pdfBase64
    };

    // Send to DocuSign
    const docusignResult = await docusignService.sendEnvelope(contractData);

    // Update contract with DocuSign information
    contract.externalProvider = 'docusign';
    contract.externalAgreementId = docusignResult.envelopeId;
    contract.externalEnvelopeId = docusignResult.envelopeId;
    contract.recipientEmail = recipientEmail;
    contract.recipientName = recipientName || recipientEmail;
    contract.status = 'sent';
    contract.sentAt = new Date();
    contract.docusignStatus = docusignResult.status;
    contract.expiresAt = new Date(Date.now() + (30 * 24 * 60 * 60 * 1000)); // 30 days from now
    contract.updatedAt = new Date();

    await contract.save();

    res.json({ 
      msg: 'Contract sent for signature via DocuSign', 
      envelopeId: docusignResult.envelopeId, 
      status: docusignResult.status,
      recipientEmail,
      expiresAt: contract.expiresAt
    });

  } catch (error) {
    console.error('sendForSignature error:', error.message);
    res.status(500).json({ 
      msg: 'Failed to send contract for signature', 
      error: error.message 
    });
  }
};

// Download contract PDF
const downloadContract = async (req, res) => {
  try {
    const contract = await GeneratedContract.findById(req.params.id);
    if (!contract || !contract.generatedDocUrl) return res.status(404).json({ msg: 'Contract or PDF not found' });
    
    console.log('Contract found:', contract.name);
    console.log('Generated doc URL:', contract.generatedDocUrl);
    
    // Handle both relative and absolute URLs
    let filePath = contract.generatedDocUrl;
    if (filePath.startsWith('http')) {
      // If it's an absolute URL, extract the file path
      const url = new URL(filePath);
      filePath = url.pathname;
    }
    
    // Remove leading slash if present
    if (filePath.startsWith('/')) filePath = filePath.slice(1);
    const absPath = path.resolve(__dirname, '../..', filePath);
    
    console.log('Resolved file path:', absPath);
    console.log('File exists:', fs.existsSync(absPath));
    
    if (!fs.existsSync(absPath)) {
      console.error('PDF file not found at:', absPath);
      return res.status(404).json({ msg: 'PDF file not found on server' });
    }
    
    res.download(absPath, err => {
      if (err) {
        console.error('Download error:', err);
        res.status(500).send('Error downloading file');
      }
    });
  } catch (error) {
    console.error('Download contract error:', error);
    res.status(500).send('Server error');
  }
};

// Get contract signature status
const getContractStatus = async (req, res) => {
  try {
    const contract = await GeneratedContract.findById(req.params.id);
    if (!contract) return res.status(404).json({ msg: 'Contract not found' });

    if (contract.externalProvider === 'docusign' && contract.externalEnvelopeId) {
      try {
        const status = await docusignService.getEnvelopeStatus(contract.externalEnvelopeId);
        
        // Update contract status if it changed
        if (status.status !== contract.docusignStatus) {
          contract.docusignStatus = status.status;
          contract.updatedAt = new Date();
          
          // Map DocuSign status to our status
          if (status.status === 'completed') {
            contract.status = 'signed';
            contract.signedAt = new Date();
          } else if (status.status === 'declined') {
            contract.status = 'declined';
          } else if (status.status === 'voided') {
            contract.status = 'cancelled';
          } else if (status.status === 'expired') {
            contract.status = 'expired';
          }
          
          await contract.save();
        }

        res.json({
          contractId: contract._id,
          status: contract.status,
          docusignStatus: contract.docusignStatus,
          recipientEmail: contract.recipientEmail,
          sentAt: contract.sentAt,
          signedAt: contract.signedAt,
          expiresAt: contract.expiresAt
        });
      } catch (error) {
        console.error('Error getting DocuSign status:', error.message);
        res.json({
          contractId: contract._id,
          status: contract.status,
          docusignStatus: contract.docusignStatus,
          error: 'Failed to get latest status from DocuSign'
        });
      }
    } else {
      res.json({
        contractId: contract._id,
        status: contract.status,
        docusignStatus: contract.docusignStatus,
        recipientEmail: contract.recipientEmail,
        sentAt: contract.sentAt,
        signedAt: contract.signedAt,
        expiresAt: contract.expiresAt
      });
    }
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};

// DocuSign webhook handler
const handleDocuSignWebhook = async (req, res) => {
  try {
    const eventData = req.body;
    const processedEvent = await docusignService.processWebhookEvent(eventData);
    
    // Find contract by envelope ID
    const contract = await GeneratedContract.findOne({ 
      externalEnvelopeId: processedEvent.envelopeId 
    });
    
    if (contract) {
      // Update contract status
      contract.docusignStatus = processedEvent.status;
      contract.updatedAt = new Date();
      
      // Add event to history
      contract.docusignEvents.push({
        event: processedEvent.event,
        timestamp: processedEvent.timestamp,
        data: eventData
      });
      
      // Update main status based on DocuSign status
      if (processedEvent.status === 'completed') {
        contract.status = 'signed';
        contract.signedAt = new Date();
      } else if (processedEvent.status === 'declined') {
        contract.status = 'declined';
      } else if (processedEvent.status === 'voided') {
        contract.status = 'cancelled';
      } else if (processedEvent.status === 'expired') {
        contract.status = 'expired';
      }
      
      await contract.save();
    }
    
    res.status(200).json({ msg: 'Webhook processed successfully' });
  } catch (error) {
    console.error('DocuSign webhook error:', error);
    res.status(500).json({ msg: 'Webhook processing failed' });
  }
};

// Delete a generated contract
const deleteGeneratedContract = async (req, res) => {
  try {
    await GeneratedContract.findByIdAndDelete(req.params.id);
    res.json({ msg: 'Contract deleted' });
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};

module.exports = {
  getAllGeneratedContracts,
  getGeneratedContract,
  generateContract,
  sendForSignature,
  downloadContract,
  getContractStatus,
  handleDocuSignWebhook,
  deleteGeneratedContract,
}; 