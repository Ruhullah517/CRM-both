const GeneratedContract = require('../models/Contract');
const ContractTemplate = require('../models/ContractTemplate');
const { PDFDocument, StandardFonts, rgb } = require('pdf-lib');
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const docusignService = require('../utils/docusign');
const { convert } = require('html-to-text');

// List all generated contracts
const getAllGeneratedContracts = async (req, res) => {
  try {
    const contracts = await GeneratedContract.find().populate('templateId').populate('generatedBy', 'name email');
    res.json(contracts);
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};

// Get a single generated contract by ID
const getGeneratedContract = async (req, res) => {
  try {
    const contract = await GeneratedContract.findById(req.params.id).populate('templateId').populate('generatedBy', 'name email');
    if (!contract) return res.status(404).json({ msg: 'Contract not found' });
    res.json(contract);
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};

// Generate a new contract from template and filled data
const generateContract = async (req, res) => {
  const { name, templateId, roleType, generatedBy, filledData, status } = req.body;
  
  // Valid status values
  const validStatuses = ['draft', 'pending', 'sent', 'delivered', 'signed', 'completed', 'declined', 'cancelled', 'expired'];
  const contractStatus = validStatuses.includes(status) ? status : 'draft';
  
  try {
    // Validate required fields
    if (!templateId) {
      return res.status(400).json({ msg: 'Template ID is required' });
    }
    
    if (!generatedBy) {
      return res.status(400).json({ msg: 'Generated By is required' });
    }

    // Fetch template and validate placeholders
    const template = await ContractTemplate.findById(templateId);
    if (!template) {
      return res.status(400).json({ msg: 'Template not found' });
    }

    // Fill template content
    let filledContent = template.content;
    if (filledData && typeof filledData === 'object') {
      Object.entries(filledData).forEach(([ph, val]) => {
        filledContent = filledContent.replace(new RegExp(`{{\\s*${ph}\\s*}}`, 'g'), val || `[${ph}]`);
      });
    }

    // Convert HTML to plain text for PDF generation
    const plainTextContent = convert(filledContent, {
      wordwrap: 80,
      preserveNewlines: true
    });

    // Generate PDF with new professional multi-page structure
    const pdfDoc = await PDFDocument.create();
    
    // Get standard A4 page dimensions (595.28 x 841.89 points)
    const width = 595.28;
    const height = 841.89;
    
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
    const italicFont = await pdfDoc.embedFont(StandardFonts.HelveticaOblique);
    
    // Load logo for use across pages
    let logoImage = null;
    try {
      const logoPaths = [
        path.join(__dirname, '../uploads/logo.png'),
        path.join(__dirname, '../uploads/logo.PNG'),
        path.join(__dirname, '../../client/public/logo.PNG'),
        path.join(__dirname, '../../client/public/logo.png')
      ];
      
      for (const logoPath of logoPaths) {
        if (fs.existsSync(logoPath)) {
          const logoBytes = fs.readFileSync(logoPath);
          if (logoPath.toLowerCase().endsWith('.png')) {
            logoImage = await pdfDoc.embedPng(logoBytes);
          } else {
            logoImage = await pdfDoc.embedJpg(logoBytes);
          }
          break;
        }
      }
    } catch (error) {
      console.error('Error loading logo:', error);
    }
    
    // PAGE 1 - COVER PAGE
    const coverPage = pdfDoc.addPage();
    
    // Background color for cover page
    coverPage.drawRectangle({
      x: 0,
      y: 0,
      width: width,
      height: height,
      color: rgb(0.875, 0.392, 0.239), // #df643d
    });

    // Centered logo at the top
    if (logoImage) {
      const logoSize = 120;
      const logoX = (width - logoSize) / 2;
      const logoY = height - 200;
      coverPage.drawImage(logoImage, {
        x: logoX,
        y: logoY,
        width: logoSize,
        height: logoSize,
      });
    }

    // Contract title (centered)
    const contractTitle = filledData?.contract_title || name || 'Service Level Agreement';
    const titleWidth = boldFont.widthOfTextAtSize(contractTitle, 28);
    coverPage.drawText(contractTitle, {
      x: (width - titleWidth) / 2,
      y: height - 350,
      size: 28,
      font: boldFont,
      color: rgb(0, 0, 0),
    });

    // Optional subtitle
    const subtitle = 'Black Foster Carers Alliance';
    const subtitleWidth = font.widthOfTextAtSize(subtitle, 16);
    coverPage.drawText(subtitle, {
      x: (width - subtitleWidth) / 2,
      y: height - 400,
      size: 16,
      font: font,
      color: rgb(0, 0, 0),
    });

    // Footer
    const footerText = 'Registered Company No. 15210072 | BLACK FOSTER CARERS ALLIANCE';
    const footerWidth = font.widthOfTextAtSize(footerText, 10);
    coverPage.drawText(footerText, {
      x: (width - footerWidth) / 2,
      y: 80,
      size: 10, 
      font: font,
      color: rgb(0, 0, 0),
    });

    // PAGE 2 - n (CONTENT PAGES)
    const contentPage = pdfDoc.addPage();
    
    // Background for content pages
    contentPage.drawRectangle({
      x: 0,
      y: 0,
      width: width,
      height: height,
      color: rgb(1, 1, 1), // White
    });

    // Logo at top-right corner
    if (logoImage) {
      const logoSize = 60;
      contentPage.drawImage(logoImage, {
        x: width - logoSize - 20,
        y: height - logoSize - 20,
        width: logoSize,
        height: logoSize,
      });
    }

    // Render content with proper formatting
    const renderContent = (page, content, startY) => {
      let currentY = startY;
      const lineHeight = 16;
      const margin = 50;
      const maxWidth = width - (margin * 2);
      
      // Convert HTML to plain text and split into paragraphs
      const plainText = convert(content, {
        wordwrap: false,
        preserveNewlines: true
      });
      
      const paragraphs = plainText.split('\n\n');
      
      paragraphs.forEach(paragraph => {
        if (!paragraph.trim()) return;
        
        // Split paragraph by single newlines to handle line breaks
        const lines = paragraph.split('\n').filter(line => line.trim());
        
        lines.forEach(lineText => {
          // Check if we need a new page
          if (currentY < 100) {
            // Create new page
            const newPage = pdfDoc.addPage();
            
            // Add logo to new page
            if (logoImage) {
              const logoSize = 60;
              newPage.drawImage(logoImage, {
                x: width - logoSize - 20,
                y: height - logoSize - 20,
                width: logoSize,
                height: logoSize,
              });
            }
            
            currentY = height - 100;
            page = newPage; // Update page reference
          }
          
          // Split line into words that fit within maxWidth
          const words = lineText.trim().split(' ');
          let line = '';
          words.forEach((word) => {
            // Remove any remaining newline characters from word
            const cleanWord = word.replace(/[\n\r]/g, ' ').trim();
            if (!cleanWord) return;
            
            const testLine = line + (line ? ' ' : '') + cleanWord;
            const lineWidth = font.widthOfTextAtSize(testLine, 12);
            if (lineWidth > maxWidth && line) {
              page.drawText(line, {
                x: margin,
                    y: currentY, 
                size: 12,
                font: font,
                color: rgb(0, 0, 0),
                  });
                  currentY -= lineHeight;
              line = cleanWord;
                } else {
              line = testLine;
            }
          });
          if (line) {
            page.drawText(line, {
              x: margin,
              y: currentY,
              size: 12,
              font: font,
              color: rgb(0, 0, 0),
            });
          currentY -= lineHeight;
        }
        });
        
        currentY -= 10; // Extra spacing between paragraphs
      });
      
      return currentY;
    };
    
    // Render main content
    renderContent(contentPage, filledContent, height - 100);

    // FINAL PAGE - CONTACT PAGE
    const contactPage = pdfDoc.addPage();
    
    // Background color for contact page
    contactPage.drawRectangle({
      x: 0,
      y: 0,
      width: width,
      height: height,
      color: rgb(0.875, 0.392, 0.239), // #df643d
    });

    // "Reach out to us" heading (centered)
    const contactHeading = 'Reach out to us';
    const headingWidth = boldFont.widthOfTextAtSize(contactHeading, 24);
    contactPage.drawText(contactHeading, {
      x: (width - headingWidth) / 2,
      y: height - 200,
      size: 24,
      font: boldFont,
      color: rgb(0, 0, 0),
    });

    // Contact details (centered)
    const contactDetails = [
      '0800 001 6230',
      'Enquiries@blackfostercarersalliance.co.uk',
      'Blackfostercarersalliance',
      'www.blackfostercarersalliance.co.uk'
    ];

    let contactY = height - 280;
    contactDetails.forEach((detail, index) => {
      const detailWidth = font.widthOfTextAtSize(detail, 16);
      contactPage.drawText(detail, {
        x: (width - detailWidth) / 2,
        y: contactY,
        size: 16,
        font: font,
        color: rgb(0, 0, 0),
      });
      contactY -= 30;
    });

    // Footer
    const contactFooter = '| BLACK FOSTER CARERS ALLIANCE | Registered Company No. 15210072 |';
    const contactFooterWidth = font.widthOfTextAtSize(contactFooter, 10);
    contactPage.drawText(contactFooter, {
      x: (width - contactFooterWidth) / 2,
      y: 80,
      size: 10,
      font: font,
      color: rgb(0, 0, 0),
    });
    
    const pdfBytes = await pdfDoc.save();
    
    // Save PDF to disk
    const dirPath = path.join(__dirname, '../uploads/contracts');
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }
    
    const fileName = `contract_${Date.now()}.pdf`;
    const filePath = path.join(dirPath, fileName);
    fs.writeFileSync(filePath, pdfBytes);
    
    // Use the correct server URL for the generated document URL
    const serverUrl = process.env.SERVER_URL || 'https://crm-backend-0v14.onrender.com';
    const generatedDocUrl = `${serverUrl}/uploads/contracts/${fileName}`;
    
    console.log('PDF saved to:', filePath);
    console.log('Generated doc URL:', generatedDocUrl);
    console.log('File exists after save:', fs.existsSync(filePath));

    if (req.body._id) {
      // Update existing contract
      const updated = await GeneratedContract.findByIdAndUpdate(
        req.body._id,
        {
          name,
          templateId,
          roleType,
          generatedBy,
          filledData,
          generatedDocUrl,
          status: contractStatus,
        },
        { new: true }
      );
      res.status(200).json(updated);
    } else {
      // Create new contract
      const contract = new GeneratedContract({
        name,
        templateId,
        roleType,
        generatedBy,
        filledData,
        generatedDocUrl,
        status: contractStatus,
      });
      await contract.save();
      res.status(201).json(contract);
    }
  } catch (error) {
    console.error('Contract generation error:', error);
    res.status(500).json({ 
      msg: 'Server error during contract generation',
      error: error.message 
    });
  }
};

// Send contract for e-signature via DocuSign
const sendForSignature = async (req, res) => {
  try {
    const { id } = req.params;
    const { recipientEmail, recipientName } = req.body;
    const contract = await GeneratedContract.findById(id);
    
    if (!contract) return res.status(404).json({ msg: 'Contract not found' });
    if (!contract.generatedDocUrl) return res.status(400).json({ msg: 'Generated PDF not found' });
    if (!recipientEmail) return res.status(400).json({ msg: 'Recipient email is required' });

    // Build absolute path to PDF
    let filePath = contract.generatedDocUrl;
    if (filePath.startsWith('http')) {
      // If it's an absolute URL, extract the file path
      const url = new URL(filePath);
      filePath = url.pathname;
    }
    if (filePath.startsWith('/')) filePath = filePath.slice(1);
    const absPath = path.resolve(__dirname, '../..', filePath);

    // Read PDF file and convert to base64
    const pdfBuffer = fs.readFileSync(absPath);
    const pdfBase64 = pdfBuffer.toString('base64');

    // Prepare contract data for DocuSign
    const contractData = {
      name: contract.name || 'BFCA Contract',
      recipientEmail,
      recipientName: recipientName || recipientEmail,
      pdfBase64
    };

    // Send to DocuSign
    const docusignResult = await docusignService.sendEnvelope(contractData);

    // Update contract with DocuSign information
    contract.externalProvider = 'docusign';
    contract.externalAgreementId = docusignResult.envelopeId;
    contract.externalEnvelopeId = docusignResult.envelopeId;
    contract.recipientEmail = recipientEmail;
    contract.recipientName = recipientName || recipientEmail;
    contract.status = 'sent';
    contract.sentAt = new Date();
    contract.docusignStatus = docusignResult.status;
    contract.expiresAt = new Date(Date.now() + (30 * 24 * 60 * 60 * 1000)); // 30 days from now
    contract.updatedAt = new Date();

    await contract.save();

    res.json({ 
      msg: 'Contract sent for signature via DocuSign', 
      envelopeId: docusignResult.envelopeId, 
      status: docusignResult.status,
      recipientEmail,
      expiresAt: contract.expiresAt
    });

  } catch (error) {
    console.error('sendForSignature error:', error.message);
    res.status(500).json({ 
      msg: 'Failed to send contract for signature', 
      error: error.message 
    });
  }
};

// Download contract PDF
const downloadContract = async (req, res) => {
  try {
    const contract = await GeneratedContract.findById(req.params.id);
    if (!contract || !contract.generatedDocUrl) return res.status(404).json({ msg: 'Contract or PDF not found' });
    
    console.log('Contract found:', contract.name);
    console.log('Generated doc URL:', contract.generatedDocUrl);
    
    // Handle both relative and absolute URLs
    let filePath = contract.generatedDocUrl;
    if (filePath.startsWith('http')) {
      // If it's an absolute URL, extract the file path
      const url = new URL(filePath);
      filePath = url.pathname;
    }
    
    // Remove leading slash if present
    if (filePath.startsWith('/')) filePath = filePath.slice(1);
    const absPath = path.resolve(__dirname, '../..', filePath);
    
    console.log('Resolved file path:', absPath);
    console.log('File exists:', fs.existsSync(absPath));
    
    if (!fs.existsSync(absPath)) {
      console.error('PDF file not found at:', absPath);
      return res.status(404).json({ msg: 'PDF file not found on server' });
    }
    
    res.download(absPath, err => {
      if (err) {
        console.error('Download error:', err);
        res.status(500).send('Error downloading file');
      }
    });
  } catch (error) {
    console.error('Download contract error:', error);
    res.status(500).send('Server error');
  }
};

// Get contract signature status
const getContractStatus = async (req, res) => {
  try {
    const contract = await GeneratedContract.findById(req.params.id);
    if (!contract) return res.status(404).json({ msg: 'Contract not found' });

    if (contract.externalProvider === 'docusign' && contract.externalEnvelopeId) {
      try {
        const status = await docusignService.getEnvelopeStatus(contract.externalEnvelopeId);
        
        // Update contract status if it changed
        if (status.status !== contract.docusignStatus) {
          contract.docusignStatus = status.status;
          contract.updatedAt = new Date();
          
          // Map DocuSign status to our status
          if (status.status === 'completed') {
            contract.status = 'signed';
            contract.signedAt = new Date();
          } else if (status.status === 'declined') {
            contract.status = 'declined';
          } else if (status.status === 'voided') {
            contract.status = 'cancelled';
          } else if (status.status === 'expired') {
            contract.status = 'expired';
          }
          
          await contract.save();
        }

        res.json({
          contractId: contract._id,
          status: contract.status,
          docusignStatus: contract.docusignStatus,
          recipientEmail: contract.recipientEmail,
          sentAt: contract.sentAt,
          signedAt: contract.signedAt,
          expiresAt: contract.expiresAt
        });
      } catch (error) {
        console.error('Error getting DocuSign status:', error.message);
        res.json({
          contractId: contract._id,
          status: contract.status,
          docusignStatus: contract.docusignStatus,
          error: 'Failed to get latest status from DocuSign'
        });
      }
    } else {
      res.json({
        contractId: contract._id,
        status: contract.status,
        docusignStatus: contract.docusignStatus,
        recipientEmail: contract.recipientEmail,
        sentAt: contract.sentAt,
        signedAt: contract.signedAt,
        expiresAt: contract.expiresAt
      });
    }
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};

// DocuSign webhook handler
const handleDocuSignWebhook = async (req, res) => {
  try {
    const eventData = req.body;
    const processedEvent = await docusignService.processWebhookEvent(eventData);
    
    // Find contract by envelope ID
    const contract = await GeneratedContract.findOne({ 
      externalEnvelopeId: processedEvent.envelopeId 
    });
    
    if (contract) {
      // Update contract status
      contract.docusignStatus = processedEvent.status;
      contract.updatedAt = new Date();
      
      // Add event to history
      contract.docusignEvents.push({
        event: processedEvent.event,
        timestamp: processedEvent.timestamp,
        data: eventData
      });
      
      // Update main status based on DocuSign status
      if (processedEvent.status === 'completed') {
        contract.status = 'signed';
        contract.signedAt = new Date();
      } else if (processedEvent.status === 'declined') {
        contract.status = 'declined';
      } else if (processedEvent.status === 'voided') {
        contract.status = 'cancelled';
      } else if (processedEvent.status === 'expired') {
        contract.status = 'expired';
      }
      
      await contract.save();
    }
    
    res.status(200).json({ msg: 'Webhook processed successfully' });
  } catch (error) {
    console.error('DocuSign webhook error:', error);
    res.status(500).json({ msg: 'Webhook processing failed' });
  }
};

// Delete a generated contract
const deleteGeneratedContract = async (req, res) => {
  try {
    await GeneratedContract.findByIdAndDelete(req.params.id);
    res.json({ msg: 'Contract deleted' });
  } catch (error) {
    console.error(error);
    res.status(500).send('Server error');
  }
};

module.exports = {
  getAllGeneratedContracts,
  getGeneratedContract,
  generateContract,
  sendForSignature,
  downloadContract,
  getContractStatus,
  handleDocuSignWebhook,
  deleteGeneratedContract,
}; 